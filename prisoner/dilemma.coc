import itertools
import signal

def time_limit(func, default, time):
    class TimeOut(Exception):
        pass
    def timeout(*args, **kwargs):
        raise TimeOut()
    try:
        signal.SIGALRM
    except AttributeError:
        raise OSError("system does not support signal.SIGALRM")
    else:
        signal.signal(signal.SIGALRM, timeout)
    signal.alarm(time)
    try:
        result = func()
    except (TimeOut, RuntimeError):
        return default
    else:
        return result
    finally:
        signal.alarm(0)

default_move = False

def call(a, a_hist, b, b_hist, time=None):
    for func in a:
        if time is None:
            result = func(b_hist, a_hist, b)
        else:
            result = time_limit(func$(b_hist, a_hist, b), None, time)
        if result is not None:
            return result
    return default_move

def moves(a, b, a_hist, b_hist, time=None):
    return (call(a, a_hist, b, b_hist, time),
            call(b, b_hist, a, a_hist, time))

def game(a, b, a_hist=None, b_hist=None, time=None):
    if a_hist is None:
        a_hist = []
    else:
        a_hist = list(a_hist)
    if b_hist is None:
        b_hist = []
    else:
        b_hist = list(b_hist)
    while True:
        a_c, b_c = moves(a, b, tuple(a_hist), tuple(b_hist), time)
        a_hist.append(a_c)
        b_hist.append(b_c)
        yield a_c, b_c

default_payoffs = (
              (2,2), (0,3),
              (3,0), (1,1)
              )

def score(a_c, b_c, payoffs=default_payoffs):
    if a_c and b_c:
        return payoffs[0]
    elif a_c:
        return payoffs[1]
    elif b_c:
        return payoffs[2]
    else:
        return payoffs[3]

def tally(a, b, a_hist=None, b_hist=None, time=None, payoffs=default_payoffs):
    a_score = 0
    b_score = 0
    for a_c, b_c in game(a, b, a_hist, b_hist, time):
        a_change, b_change = score(a_c, b_c, payoffs)
        a_score += a_change
        b_score += b_change
        yield (a_score, b_score)

def predict(self_bot, self_hist, opp_bot, opp_hist, move=None):
    opp_move = call(opp_bot, opp_hist, self_bot, self_hist)
    if move is None:
        return (call(opp_bot, opp_hist+(True,), self_bot, self_hist+(opp_move,)),
                call(opp_bot, opp_hist+(False,), self_bot, self_hist+(opp_move,)))
    else:
        return call(opp_bot, opp_hist+(move,), self_bot, self_hist+(opp_move,))

def winnings(self_bot, self_hist, opp_bot, opp_hist, rounds=1, move=None, payoffs=default_payoffs):
    if rounds > 0:
        opp_move = call(opp_bot, opp_hist, self_bot, self_hist)
        if move is None:
            return (tally(self_bot, opp_bot, self_hist+(True,), opp_hist+(opp_move,), None, payoffs)$[rounds-1],
                    tally(self_bot, opp_bot, self_hist+(False,), opp_hist+(opp_move,), None, payoffs)$[rounds-1])
        else:
            return tally(self_bot, opp_bot, self_hist+(move,), opp_hist+(opp_move,), None, payoffs)$[rounds-1]
    else:
        raise ValueError("rounds must be > 0")

def simulate(self_bot, self_hist, opp_bot, opp_hist, rounds=1, move=None):
    if rounds > 0:
        opp_move = call(opp_bot, opp_hist, self_bot, self_hist)
        if move is None:
            return (game(self_bot, opp_bot, self_hist+(True,), opp_hist+(opp_move,), None)$[:rounds],
                    game(self_bot, opp_bot, self_hist+(False,), opp_hist+(opp_move,), None)$[:rounds])
        else:
            return game(self_bot, opp_bot, self_hist+(move,), opp_hist+(opp_move,), None)$[:rounds]
    else:
        raise ValueError("rounds must be > 0")

def round_robin(rounds, participants, time=None, payoffs=default_payoffs):
    if rounds > 0:
        scores = {}
        for participant in participants:
            scores[participant] = 0
        for a,b in itertools.permutations(participants.keys(), 2):
            a_score, b_score = tally(participants[a], participants[b], time=time, payoffs=payoffs)$[rounds-1]
            scores[a] += a_score
            scores[b] += b_score
        return scores
    else:
        raise ValueError("rounds must be > 0")

def score_sort(scores):
    return sorted(scores.items(), key=(item)->(item[1]))

def tournament(rounds, participants, time=None, payoffs=default_payoffs):
    while len(participants) > 1:
        scores = round_robin(rounds, participants, time=time, payoffs=payoffs)
        yield scores
        participants = participants.copy()
        lowest = None
        for name, score in score_sort(scores):
            if lowest is None:
                lowest = score
            if score == lowest:
                del participants[name]

def score_repr(scores):
    out = ["{"]
    for name, score in reversed(score_sort(scores)):
        out.append("    "+name+": "+str(score))
    out.append("}")
    return "\n".join(out)
